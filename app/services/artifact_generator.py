"""
Artifact Generator Service
Generates Dockerfiles, Kubernetes manifests, and Docker Compose files
"""
from typing import Optional
import yaml
import json


class ArtifactGenerator:
    """Generates container artifacts from VM configuration"""
    
    def __init__(self, migration, vm):
        self.migration = migration
        self.vm = vm
    
    def generate_dockerfile(self) -> str:
        """Generate Dockerfile based on VM configuration"""
        
        if self.vm.os_family == "windows":
            return self._generate_windows_dockerfile()
        else:
            return self._generate_linux_dockerfile()
    
    def _generate_windows_dockerfile(self) -> str:
        """Generate Dockerfile for Windows workloads"""
        base_image = self.migration.base_image or "mcr.microsoft.com/windows/servercore:ltsc2022"
        
        services = self.vm.discovered_services or []
        
        dockerfile = f'''# Auto-generated Dockerfile for {self.vm.name}
# Windows Container - Generated by VMShift

FROM {base_image}

# Set shell to PowerShell
SHELL ["powershell", "-Command", "$ErrorActionPreference = 'Stop';"]

# Install required Windows features
'''
        
        if "IIS" in services:
            dockerfile += '''
# Install IIS
RUN Install-WindowsFeature -Name Web-Server, Web-Asp-Net45, Web-Http-Logging -IncludeManagementTools

# Copy application files
COPY ./app /inetpub/wwwroot

# Configure IIS
RUN Remove-Website -Name 'Default Web Site'; \\
    New-Website -Name 'app' -Port 80 -PhysicalPath 'C:\\inetpub\\wwwroot'

EXPOSE 80
'''
        
        if ".NET Core" in services or "ASP.NET" in services:
            dockerfile += '''
# Install .NET Runtime
RUN Invoke-WebRequest -Uri 'https://dot.net/v1/dotnet-install.ps1' -OutFile 'dotnet-install.ps1'; \\
    ./dotnet-install.ps1 -Channel 6.0 -Runtime aspnetcore -InstallDir '/dotnet'

ENV DOTNET_ROOT="C:\\dotnet"
ENV PATH="$PATH;C:\\dotnet"
'''
        
        dockerfile += f'''
# Health check
HEALTHCHECK --interval=30s --timeout=10s --retries=3 \\
    CMD powershell -Command "try {{ $response = Invoke-WebRequest -Uri http://localhost:{self.migration.container_port or 80}/health -UseBasicParsing; if ($response.StatusCode -eq 200) {{ exit 0 }} else {{ exit 1 }} }} catch {{ exit 1 }}"

# Expose application port
EXPOSE {self.migration.container_port or 80}

# Start command
CMD ["powershell", "-NoExit", "-Command", "Start-Service W3SVC; while ($true) {{ Start-Sleep -Seconds 3600 }}"]
'''
        
        return dockerfile
    
    def _generate_linux_dockerfile(self) -> str:
        """Generate Dockerfile for Linux workloads"""
        base_image = self.migration.base_image or "ubuntu:22.04"
        
        services = self.vm.discovered_services or []
        
        dockerfile = f'''# Auto-generated Dockerfile for {self.vm.name}
# Linux Container - Generated by VMShift

FROM {base_image}

# Set environment variables
ENV DEBIAN_FRONTEND=noninteractive
ENV APP_HOME=/app

# Install base packages
RUN apt-get update && apt-get install -y \\
    curl \\
    wget \\
    ca-certificates \\
    && rm -rf /var/lib/apt/lists/*

'''
        
        if "nginx" in services:
            dockerfile += '''
# Install nginx
RUN apt-get update && apt-get install -y nginx \\
    && rm -rf /var/lib/apt/lists/*

COPY ./nginx.conf /etc/nginx/nginx.conf
COPY ./app /var/www/html

EXPOSE 80
'''
        
        if "Python Flask" in services or "Python" in services:
            dockerfile += '''
# Install Python
RUN apt-get update && apt-get install -y \\
    python3 \\
    python3-pip \\
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app
COPY requirements.txt .
RUN pip3 install --no-cache-dir -r requirements.txt

COPY ./app /app
'''
        
        dockerfile += f'''
# Health check
HEALTHCHECK --interval=30s --timeout=10s --retries=3 \\
    CMD curl -f http://localhost:{self.migration.container_port or 80}/health || exit 1

EXPOSE {self.migration.container_port or 80}

# Default command
CMD ["python3", "app.py"]
'''
        
        return dockerfile
    
    def generate_kubernetes_manifest(self) -> str:
        """Generate Kubernetes deployment and service manifests"""
        
        app_name = self.vm.name.lower().replace(" ", "-").replace("_", "-")
        namespace = self.migration.target_namespace or "default"
        image = f"{self.migration.registry_url or 'registry.example.com'}/{self.migration.image_name or app_name}:{self.migration.image_tag or 'latest'}"
        port = self.migration.container_port or 80
        replicas = self.migration.replicas or 1
        
        # Deployment
        deployment = {
            "apiVersion": "apps/v1",
            "kind": "Deployment",
            "metadata": {
                "name": app_name,
                "namespace": namespace,
                "labels": {
                    "app": app_name,
                    "migrated-from": "vmshift"
                }
            },
            "spec": {
                "replicas": replicas,
                "selector": {
                    "matchLabels": {
                        "app": app_name
                    }
                },
                "template": {
                    "metadata": {
                        "labels": {
                            "app": app_name
                        }
                    },
                    "spec": {
                        "containers": [{
                            "name": app_name,
                            "image": image,
                            "ports": [{
                                "containerPort": port
                            }],
                            "resources": {
                                "requests": {
                                    "memory": f"{self.vm.memory_mb or 512}Mi",
                                    "cpu": f"{(self.vm.cpu_count or 1) * 250}m"
                                },
                                "limits": {
                                    "memory": f"{(self.vm.memory_mb or 512) * 2}Mi",
                                    "cpu": f"{self.vm.cpu_count or 1}"
                                }
                            },
                            "livenessProbe": {
                                "httpGet": {
                                    "path": "/health",
                                    "port": port
                                },
                                "initialDelaySeconds": 30,
                                "periodSeconds": 10
                            },
                            "readinessProbe": {
                                "httpGet": {
                                    "path": "/ready",
                                    "port": port
                                },
                                "initialDelaySeconds": 5,
                                "periodSeconds": 5
                            }
                        }]
                    }
                }
            }
        }
        
        # Service
        service = {
            "apiVersion": "v1",
            "kind": "Service",
            "metadata": {
                "name": f"{app_name}-service",
                "namespace": namespace
            },
            "spec": {
                "selector": {
                    "app": app_name
                },
                "ports": [{
                    "protocol": "TCP",
                    "port": 80,
                    "targetPort": port
                }],
                "type": "ClusterIP"
            }
        }
        
        # HPA (Horizontal Pod Autoscaler)
        hpa = {
            "apiVersion": "autoscaling/v2",
            "kind": "HorizontalPodAutoscaler",
            "metadata": {
                "name": f"{app_name}-hpa",
                "namespace": namespace
            },
            "spec": {
                "scaleTargetRef": {
                    "apiVersion": "apps/v1",
                    "kind": "Deployment",
                    "name": app_name
                },
                "minReplicas": replicas,
                "maxReplicas": replicas * 3,
                "metrics": [{
                    "type": "Resource",
                    "resource": {
                        "name": "cpu",
                        "target": {
                            "type": "Utilization",
                            "averageUtilization": 70
                        }
                    }
                }]
            }
        }
        
        # Combine manifests
        manifests = [deployment, service, hpa]
        return "---\n".join([yaml.dump(m, default_flow_style=False) for m in manifests])
    
    def generate_docker_compose(self) -> str:
        """Generate Docker Compose file for local development"""
        
        app_name = self.vm.name.lower().replace(" ", "-").replace("_", "-")
        port = self.migration.container_port or 80
        
        compose = {
            "version": "3.8",
            "services": {
                app_name: {
                    "build": {
                        "context": ".",
                        "dockerfile": "Dockerfile"
                    },
                    "ports": [f"{port}:{port}"],
                    "environment": [
                        "APP_ENV=development"
                    ],
                    "volumes": [
                        "./app:/app"
                    ],
                    "healthcheck": {
                        "test": ["CMD", "curl", "-f", f"http://localhost:{port}/health"],
                        "interval": "30s",
                        "timeout": "10s",
                        "retries": 3
                    },
                    "restart": "unless-stopped"
                }
            },
            "networks": {
                "default": {
                    "driver": "bridge"
                }
            }
        }
        
        return yaml.dump(compose, default_flow_style=False)
